<!doctype html>
<html lang="en" class="h-full bg-gray-50">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>My Quest Board · Taiko Quest NATC Phoenix 2025</title>
  <meta name="color-scheme" content="light only">

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Runtime config (GENERATED; do not commit) -->
  <script src="./config.js"></script>

  <!-- html2canvas for export -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
</head>
<body class="h-full">
  <main class="max-w-6xl mx-auto p-4 sm:p-6">
    <header class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
      <div>
        <h1 class="text-2xl sm:text-3xl font-semibold">My Quest Board</h1>
        <p class="text-sm text-gray-600">Taiko Quest NATC Phoenix 2025</p>
      </div>
      <div class="flex flex-wrap items-center gap-2 text-sm">
        <span id="who" class="text-gray-600">Checking session…</span>
        <button id="signout" class="px-3 py-2 rounded-lg bg-gray-200 text-gray-900">Sign out</button>
      </div>
    </header>

    <!-- Status / actions -->
    <section class="mt-4 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
      <div class="text-sm">
        <span id="progress" class="font-medium">0/25 submitted</span>
        <span id="verified" class="ml-2 text-gray-600">0 verified</span>
      </div>
      <div class="flex flex-wrap gap-2">
        <button id="exportBtn" class="px-3 py-2 rounded-lg bg-gray-900 text-white text-sm">Export board as image</button>
        <button id="shareBtn" class="px-3 py-2 rounded-lg bg-gray-100 text-sm">Share</button>
      </div>
    </section>

    <!-- Board -->
    <section id="boardWrap" class="mt-4">
      <div id="grid"
           class="bg-white rounded-2xl shadow-sm ring-1 ring-black/5 p-3 sm:p-4 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-3">
        <!-- cells injected -->
      </div>
      <p id="note" class="text-xs text-gray-500 mt-2">
        Tip: Photos up to 2 MB, videos up to 10 MB. A coordinator will mark items as Verified ✓.
      </p>
    </section>

    <!-- Pending/consent gate -->
    <section id="gate" class="mt-6 hidden">
      <div class="bg-amber-50 text-amber-900 ring-1 ring-amber-200 rounded-2xl p-4">
        <p id="gateMsg" class="text-sm"></p>
        <div id="consentBtns" class="mt-3 hidden">
          <button id="agreeBtn" class="px-3 py-2 rounded-lg bg-gray-900 text-white text-sm">I Agree</button>
          <a href="./TERMS.html" class="px-3 py-2 rounded-lg bg-gray-100 text-sm">Read Terms</a>
        </div>
      </div>
    </section>
  </main>

  <script type="module">
    import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
    const { SUPABASE_URL, SUPABASE_KEY } = window.__ENV || {}
    if (!SUPABASE_URL || !SUPABASE_KEY) { alert('Missing Supabase config'); throw new Error('No config') }
    const supabase = createClient(SUPABASE_URL, SUPABASE_KEY)

    const who = document.getElementById('who')
    const signout = document.getElementById('signout')
    const grid = document.getElementById('grid')
    const progressEl = document.getElementById('progress')
    const verifiedEl = document.getElementById('verified')
    const exportBtn = document.getElementById('exportBtn')
    const shareBtn = document.getElementById('shareBtn')
    const gate = document.getElementById('gate')
    const gateMsg = document.getElementById('gateMsg')
    const consentBtns = document.getElementById('consentBtns')
    const agreeBtn = document.getElementById('agreeBtn')

    let currentBoardId = null

    signout.onclick = async () => { await supabase.auth.signOut(); location.href = './access.html' }

    // Boot
    supabase.auth.getUser().then(async ({ data:{ user } }) => {
      if (!user) { location.href = './access.html'; return }
      who.textContent = user.email

      // Gate: consent + approval
      const { data: p, error } = await supabase.from('profiles').select('consent,approved').eq('id', user.id).maybeSingle()
      if (error) { alert('Error loading profile: ' + error.message); return }
      if (!p?.consent) {
        gate.classList.remove('hidden')
        gateMsg.textContent = 'Please agree to media usage to continue.'
        consentBtns.classList.remove('hidden')
        agreeBtn.onclick = async () => {
          await supabase.from('profiles').update({ consent: true }).eq('id', user.id)
          location.reload()
        }
        return
      }
      if (!p?.approved) {
        gate.classList.remove('hidden')
        gateMsg.textContent = 'Your access is pending approval. Please check back later.'
        return
      }

      // Ensure board exists, then render
      const board = await ensureBoard(user.id)
      currentBoardId = board.id
      await renderBoard(board.id)
    })

    // Ensure a quest board exists for this user; create if not
    async function ensureBoard(uid) {
      const { data: b, error: bErr } = await supabase
        .from('quest_boards').select('id').eq('user_id', uid).maybeSingle()
      if (bErr) throw bErr
      if (b) return b

      // level-balanced selection with fallback
      const LEVEL_TARGETS = { easy: 13, medium: 9, hard: 3 }

      const { data: allQs, error: qErr } = await supabase
        .from('questions')
        .select('id, level, text')
        .eq('active', true)
      if (qErr) throw qErr
      if (!allQs?.length) throw new Error('No active questions found.')

      const byLevel = { easy: [], medium: [], hard: [] }
      for (const q of allQs) (byLevel[q.level] || (byLevel[q.level] = [])).push(q)

      function pick(arr, n) {
        const a = arr.slice()
        for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]] }
        return a.slice(0, n)
      }

      // First pass: pick up to targets per level
      let selected = []
      for (const lvl of ['easy','medium','hard']) {
        const want = LEVEL_TARGETS[lvl]
        const got = Math.min(want, byLevel[lvl]?.length || 0)
        selected = selected.concat(pick(byLevel[lvl] || [], got))
      }
      // Top-up to 25 from remaining pool
      if (selected.length < 25) {
        const remaining = allQs.filter(q => !selected.some(s => s.id === q.id))
        selected = selected.concat(pick(remaining, Math.max(0, 25 - selected.length)))
      }
      selected = selected.slice(0, 25)

      const { data: insertedBoards, error: iErr } = await supabase
        .from('quest_boards').insert({ user_id: uid }).select()
      if (iErr) throw iErr
      const board = insertedBoards[0]

      const items = selected.map(q => ({ board_id: board.id, question_id: q.id }))
      const { error: biErr } = await supabase.from('board_items').insert(items)
      if (biErr) throw biErr

      return board
    }

    async function renderBoard(boardId) {
      const { data: items, error } = await supabase
        .from('board_items')
        .select('id, proof_url, verified, questions(text)')
        .eq('board_id', boardId)
      if (error) { grid.innerHTML = errorCard(error.message); return }

      // Progress
      const submitted = items.filter(it => !!it.proof_url).length
      const verified = items.filter(it => !!it.verified).length
      progressEl.textContent = `${submitted}/25 submitted`
      verifiedEl.textContent = `${verified} verified`

      // Render cells
      grid.innerHTML = ''
      items.forEach((it, idx) => {
        const cell = document.createElement('div')
        cell.className = 'rounded-xl ring-1 ring-black/5 bg-white p-3 flex flex-col gap-2'
        cell.innerHTML = `
          <div class="text-xs text-gray-500">#${idx+1}</div>
          <div class="text-sm text-gray-900">${escapeHtml(it.questions?.text || '')}</div>
          <div class="flex items-center gap-2 mt-1">
            ${it.proof_url
              ? `<a href="${it.proof_url}" target="_blank" class="text-xs underline break-all">View proof</a>`
              : `<span class="text-xs text-gray-500">No proof yet</span>`
            }
            ${it.verified ? `<span class="ml-auto text-xs text-emerald-700">Verified ✓</span>` : ''}
          </div>
          <div class="flex items-center justify-between gap-2">
            <input type="file" accept="image/*,video/*" data-id="${it.id}" class="text-xs">
            <button class="btn-upload px-2.5 py-1.5 rounded-lg bg-gray-900 text-white text-xs" data-id="${it.id}">Upload</button>
          </div>
        `
        grid.appendChild(cell)
      })

      // Wire uploads
      grid.querySelectorAll('.btn-upload').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const id = e.currentTarget.dataset.id
          const inp = grid.querySelector(`input[type=file][data-id="${id}"]`)
          const file = inp?.files?.[0]
          if (!file) { alert('Choose a file first.'); return }
          await handleUpload(id, file)
          await renderBoard(boardId)
        })
      })
    }

    async function handleUpload(itemId, file) {
      const isVideo = file.type.startsWith('video/')
      const max = isVideo ? 10 * 1024 * 1024 : 2 * 1024 * 1024
      if (file.size > max) {
        alert(`File too large. Max ${isVideo ? '10MB video' : '2MB photo'}.`)
        return
      }
      const { data:{ user } } = await supabase.auth.getUser()
      const ext = (file.name.split('.').pop() || (isVideo ? 'mp4' : 'jpg')).toLowerCase().replace(/[^\w]/g,'')
      const path = `${user.id}/${itemId}/${Date.now()}.${ext}`

      const { error: upErr } = await supabase.storage.from('proofs').upload(path, file, { upsert: true })
      if (upErr) { alert('Upload failed: ' + upErr.message); return }

      const { data: pub } = supabase.storage.from('proofs').getPublicUrl(path)
      const { error: saveErr } = await supabase.from('board_items').update({ proof_url: pub.publicUrl }).eq('id', itemId)
      if (saveErr) { alert('Save failed: ' + saveErr.message) }
    }

    // Export board to image (downloads PNG)
    exportBtn.onclick = async () => {
      exportBtn.disabled = true
      try {
        const canvas = await html2canvas(document.getElementById('grid'), { backgroundColor: '#ffffff', scale: 2 })
        const url = canvas.toDataURL('image/png')
        const a = document.createElement('a')
        a.href = url
        a.download = 'taiko-quest-board.png'
        a.click()
      } catch (e) {
        alert('Export failed.')
      } finally {
        exportBtn.disabled = false
      }
    }

    // Share (when supported)
    shareBtn.onclick = async () => {
      try {
        const canvas = await html2canvas(document.getElementById('grid'), { backgroundColor: '#ffffff', scale: 2 })
        const blob = await new Promise(res => canvas.toBlob(res, 'image/png'))
        if (navigator.canShare && navigator.canShare({ files: [new File([blob], 'taiko-quest-board.png', { type: 'image/png' })] })) {
          const file = new File([blob], 'taiko-quest-board.png', { type: 'image/png' })
          await navigator.share({ files: [file], title: 'My Taiko Quest Board' })
        } else {
          // Fallback: download
          const url = URL.createObjectURL(blob)
          const a = document.createElement('a')
          a.href = url
          a.download = 'taiko-quest-board.png'
          a.click()
          URL.revokeObjectURL(url)
        }
      } catch (e) {
        alert('Share failed.')
      }
    }

    function errorCard(msg) {
      return `<div class="bg-white rounded-2xl ring-1 ring-red-300 p-6 text-red-700">Error: ${msg}</div>`
    }
    function escapeHtml(s) {
      return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]))
    }
  </script>
</body>
</html>
